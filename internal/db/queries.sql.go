// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countPostsToday = `-- name: CountPostsToday :one
SELECT COUNT(*) FROM posts
WHERE platform = ? AND posted_at >= date('now')
`

func (q *Queries) CountPostsToday(ctx context.Context, platform string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPostsToday, platform)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuotes = `-- name: CountQuotes :one
SELECT COUNT(*) FROM quotes
`

func (q *Queries) CountQuotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuotesByBook = `-- name: CountQuotesByBook :many
SELECT source_book, COUNT(*) as count FROM quotes GROUP BY source_book
`

type CountQuotesByBookRow struct {
	SourceBook string `json:"source_book"`
	Count      int64  `json:"count"`
}

func (q *Queries) CountQuotesByBook(ctx context.Context) ([]*CountQuotesByBookRow, error) {
	rows, err := q.db.QueryContext(ctx, countQuotesByBook)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CountQuotesByBookRow{}
	for rows.Next() {
		var i CountQuotesByBookRow
		if err := rows.Scan(&i.SourceBook, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countQuotesWithEmbeddings = `-- name: CountQuotesWithEmbeddings :one
SELECT COUNT(*) FROM quotes WHERE embedding IS NOT NULL
`

func (q *Queries) CountQuotesWithEmbeddings(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotesWithEmbeddings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExtractionJob = `-- name: CreateExtractionJob :one
INSERT INTO extraction_jobs (book_title, file_path, status)
VALUES (?, ?, 'pending')
RETURNING id, book_title, file_path, total_chunks, processed_chunks, quotes_extracted, status, error_message, started_at, completed_at, created_at
`

type CreateExtractionJobParams struct {
	BookTitle string `json:"book_title"`
	FilePath  string `json:"file_path"`
}

func (q *Queries) CreateExtractionJob(ctx context.Context, arg CreateExtractionJobParams) (*ExtractionJob, error) {
	row := q.db.QueryRowContext(ctx, createExtractionJob, arg.BookTitle, arg.FilePath)
	var i ExtractionJob
	err := row.Scan(
		&i.ID,
		&i.BookTitle,
		&i.FilePath,
		&i.TotalChunks,
		&i.ProcessedChunks,
		&i.QuotesExtracted,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
    quote_id, platform, platform_post_id, post_url,
    trend_id, trend_title, trend_source, trend_hash,
    relevance_score, relevance_reasoning, vector_similarity
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, quote_id, platform, platform_post_id, post_url, trend_id, trend_title, trend_source, trend_hash, relevance_score, relevance_reasoning, vector_similarity, likes, reposts, replies, posted_at
`

type CreatePostParams struct {
	QuoteID            int64          `json:"quote_id"`
	Platform           string         `json:"platform"`
	PlatformPostID     sql.NullString `json:"platform_post_id"`
	PostUrl            sql.NullString `json:"post_url"`
	TrendID            sql.NullInt64  `json:"trend_id"`
	TrendTitle         string         `json:"trend_title"`
	TrendSource        string         `json:"trend_source"`
	TrendHash          string         `json:"trend_hash"`
	RelevanceScore     float64        `json:"relevance_score"`
	RelevanceReasoning sql.NullString `json:"relevance_reasoning"`
	VectorSimilarity   float64        `json:"vector_similarity"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (*Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.QuoteID,
		arg.Platform,
		arg.PlatformPostID,
		arg.PostUrl,
		arg.TrendID,
		arg.TrendTitle,
		arg.TrendSource,
		arg.TrendHash,
		arg.RelevanceScore,
		arg.RelevanceReasoning,
		arg.VectorSimilarity,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.QuoteID,
		&i.Platform,
		&i.PlatformPostID,
		&i.PostUrl,
		&i.TrendID,
		&i.TrendTitle,
		&i.TrendSource,
		&i.TrendHash,
		&i.RelevanceScore,
		&i.RelevanceReasoning,
		&i.VectorSimilarity,
		&i.Likes,
		&i.Reposts,
		&i.Replies,
		&i.PostedAt,
	)
	return &i, err
}

const createQuote = `-- name: CreateQuote :one
INSERT INTO quotes (
    text, text_hash, source_book, chapter, character,
    themes, modern_relevance, char_count
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at
`

type CreateQuoteParams struct {
	Text            string         `json:"text"`
	TextHash        string         `json:"text_hash"`
	SourceBook      string         `json:"source_book"`
	Chapter         sql.NullString `json:"chapter"`
	Character       sql.NullString `json:"character"`
	Themes          string         `json:"themes"`
	ModernRelevance sql.NullString `json:"modern_relevance"`
	CharCount       int64          `json:"char_count"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) (*Quote, error) {
	row := q.db.QueryRowContext(ctx, createQuote,
		arg.Text,
		arg.TextHash,
		arg.SourceBook,
		arg.Chapter,
		arg.Character,
		arg.Themes,
		arg.ModernRelevance,
		arg.CharCount,
	)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.TextHash,
		&i.SourceBook,
		&i.Chapter,
		&i.Character,
		&i.Themes,
		&i.ModernRelevance,
		&i.Embedding,
		&i.CharCount,
		&i.TimesPosted,
		&i.LastPostedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const createTrend = `-- name: CreateTrend :one
INSERT INTO trends (source, external_id, title, url, description, score)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, source, external_id, title, url, description, score, embedding, matched, skipped, skip_reason, detected_at
`

type CreateTrendParams struct {
	Source      string         `json:"source"`
	ExternalID  sql.NullString `json:"external_id"`
	Title       string         `json:"title"`
	Url         sql.NullString `json:"url"`
	Description sql.NullString `json:"description"`
	Score       sql.NullInt64  `json:"score"`
}

func (q *Queries) CreateTrend(ctx context.Context, arg CreateTrendParams) (*Trend, error) {
	row := q.db.QueryRowContext(ctx, createTrend,
		arg.Source,
		arg.ExternalID,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.Score,
	)
	var i Trend
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.ExternalID,
		&i.Title,
		&i.Url,
		&i.Description,
		&i.Score,
		&i.Embedding,
		&i.Matched,
		&i.Skipped,
		&i.SkipReason,
		&i.DetectedAt,
	)
	return &i, err
}

const getConfig = `-- name: GetConfig :one
SELECT value FROM config WHERE key = ?
`

func (q *Queries) GetConfig(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRowContext(ctx, getConfig, key)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getExtractionJob = `-- name: GetExtractionJob :one
SELECT id, book_title, file_path, total_chunks, processed_chunks, quotes_extracted, status, error_message, started_at, completed_at, created_at FROM extraction_jobs WHERE id = ? LIMIT 1
`

func (q *Queries) GetExtractionJob(ctx context.Context, id int64) (*ExtractionJob, error) {
	row := q.db.QueryRowContext(ctx, getExtractionJob, id)
	var i ExtractionJob
	err := row.Scan(
		&i.ID,
		&i.BookTitle,
		&i.FilePath,
		&i.TotalChunks,
		&i.ProcessedChunks,
		&i.QuotesExtracted,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getExtractionJobByBook = `-- name: GetExtractionJobByBook :one
SELECT id, book_title, file_path, total_chunks, processed_chunks, quotes_extracted, status, error_message, started_at, completed_at, created_at FROM extraction_jobs WHERE book_title = ? ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetExtractionJobByBook(ctx context.Context, bookTitle string) (*ExtractionJob, error) {
	row := q.db.QueryRowContext(ctx, getExtractionJobByBook, bookTitle)
	var i ExtractionJob
	err := row.Scan(
		&i.ID,
		&i.BookTitle,
		&i.FilePath,
		&i.TotalChunks,
		&i.ProcessedChunks,
		&i.QuotesExtracted,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getPost = `-- name: GetPost :one
SELECT id, quote_id, platform, platform_post_id, post_url, trend_id, trend_title, trend_source, trend_hash, relevance_score, relevance_reasoning, vector_similarity, likes, reposts, replies, posted_at FROM posts WHERE id = ? LIMIT 1
`

func (q *Queries) GetPost(ctx context.Context, id int64) (*Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.QuoteID,
		&i.Platform,
		&i.PlatformPostID,
		&i.PostUrl,
		&i.TrendID,
		&i.TrendTitle,
		&i.TrendSource,
		&i.TrendHash,
		&i.RelevanceScore,
		&i.RelevanceReasoning,
		&i.VectorSimilarity,
		&i.Likes,
		&i.Reposts,
		&i.Replies,
		&i.PostedAt,
	)
	return &i, err
}

const getPostByTrendHash = `-- name: GetPostByTrendHash :one
SELECT id, quote_id, platform, platform_post_id, post_url, trend_id, trend_title, trend_source, trend_hash, relevance_score, relevance_reasoning, vector_similarity, likes, reposts, replies, posted_at FROM posts WHERE trend_hash = ? AND platform = ? LIMIT 1
`

type GetPostByTrendHashParams struct {
	TrendHash string `json:"trend_hash"`
	Platform  string `json:"platform"`
}

func (q *Queries) GetPostByTrendHash(ctx context.Context, arg GetPostByTrendHashParams) (*Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByTrendHash, arg.TrendHash, arg.Platform)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.QuoteID,
		&i.Platform,
		&i.PlatformPostID,
		&i.PostUrl,
		&i.TrendID,
		&i.TrendTitle,
		&i.TrendSource,
		&i.TrendHash,
		&i.RelevanceScore,
		&i.RelevanceReasoning,
		&i.VectorSimilarity,
		&i.Likes,
		&i.Reposts,
		&i.Replies,
		&i.PostedAt,
	)
	return &i, err
}

const getQuote = `-- name: GetQuote :one
SELECT id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at FROM quotes WHERE id = ? LIMIT 1
`

func (q *Queries) GetQuote(ctx context.Context, id int64) (*Quote, error) {
	row := q.db.QueryRowContext(ctx, getQuote, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.TextHash,
		&i.SourceBook,
		&i.Chapter,
		&i.Character,
		&i.Themes,
		&i.ModernRelevance,
		&i.Embedding,
		&i.CharCount,
		&i.TimesPosted,
		&i.LastPostedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getQuoteByHash = `-- name: GetQuoteByHash :one
SELECT id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at FROM quotes WHERE text_hash = ? LIMIT 1
`

func (q *Queries) GetQuoteByHash(ctx context.Context, textHash string) (*Quote, error) {
	row := q.db.QueryRowContext(ctx, getQuoteByHash, textHash)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.TextHash,
		&i.SourceBook,
		&i.Chapter,
		&i.Character,
		&i.Themes,
		&i.ModernRelevance,
		&i.Embedding,
		&i.CharCount,
		&i.TimesPosted,
		&i.LastPostedAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getTrend = `-- name: GetTrend :one
SELECT id, source, external_id, title, url, description, score, embedding, matched, skipped, skip_reason, detected_at FROM trends WHERE id = ? LIMIT 1
`

func (q *Queries) GetTrend(ctx context.Context, id int64) (*Trend, error) {
	row := q.db.QueryRowContext(ctx, getTrend, id)
	var i Trend
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.ExternalID,
		&i.Title,
		&i.Url,
		&i.Description,
		&i.Score,
		&i.Embedding,
		&i.Matched,
		&i.Skipped,
		&i.SkipReason,
		&i.DetectedAt,
	)
	return &i, err
}

const getTrendBySourceAndExternalID = `-- name: GetTrendBySourceAndExternalID :one
SELECT id, source, external_id, title, url, description, score, embedding, matched, skipped, skip_reason, detected_at FROM trends WHERE source = ? AND external_id = ? LIMIT 1
`

type GetTrendBySourceAndExternalIDParams struct {
	Source     string         `json:"source"`
	ExternalID sql.NullString `json:"external_id"`
}

func (q *Queries) GetTrendBySourceAndExternalID(ctx context.Context, arg GetTrendBySourceAndExternalIDParams) (*Trend, error) {
	row := q.db.QueryRowContext(ctx, getTrendBySourceAndExternalID, arg.Source, arg.ExternalID)
	var i Trend
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.ExternalID,
		&i.Title,
		&i.Url,
		&i.Description,
		&i.Score,
		&i.Embedding,
		&i.Matched,
		&i.Skipped,
		&i.SkipReason,
		&i.DetectedAt,
	)
	return &i, err
}

const listConfig = `-- name: ListConfig :many
SELECT "key", value, updated_at FROM config ORDER BY key
`

func (q *Queries) ListConfig(ctx context.Context) ([]*Config, error) {
	rows, err := q.db.QueryContext(ctx, listConfig)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Config{}
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExtractionJobs = `-- name: ListExtractionJobs :many
SELECT id, book_title, file_path, total_chunks, processed_chunks, quotes_extracted, status, error_message, started_at, completed_at, created_at FROM extraction_jobs ORDER BY created_at DESC
`

func (q *Queries) ListExtractionJobs(ctx context.Context) ([]*ExtractionJob, error) {
	rows, err := q.db.QueryContext(ctx, listExtractionJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExtractionJob{}
	for rows.Next() {
		var i ExtractionJob
		if err := rows.Scan(
			&i.ID,
			&i.BookTitle,
			&i.FilePath,
			&i.TotalChunks,
			&i.ProcessedChunks,
			&i.QuotesExtracted,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT id, quote_id, platform, platform_post_id, post_url, trend_id, trend_title, trend_source, trend_hash, relevance_score, relevance_reasoning, vector_similarity, likes, reposts, replies, posted_at FROM posts ORDER BY posted_at DESC LIMIT ? OFFSET ?
`

type ListPostsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]*Post, error) {
	rows, err := q.db.QueryContext(ctx, listPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Post{}
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.QuoteID,
			&i.Platform,
			&i.PlatformPostID,
			&i.PostUrl,
			&i.TrendID,
			&i.TrendTitle,
			&i.TrendSource,
			&i.TrendHash,
			&i.RelevanceScore,
			&i.RelevanceReasoning,
			&i.VectorSimilarity,
			&i.Likes,
			&i.Reposts,
			&i.Replies,
			&i.PostedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByPlatform = `-- name: ListPostsByPlatform :many
SELECT id, quote_id, platform, platform_post_id, post_url, trend_id, trend_title, trend_source, trend_hash, relevance_score, relevance_reasoning, vector_similarity, likes, reposts, replies, posted_at FROM posts WHERE platform = ? ORDER BY posted_at DESC LIMIT ?
`

type ListPostsByPlatformParams struct {
	Platform string `json:"platform"`
	Limit    int64  `json:"limit"`
}

func (q *Queries) ListPostsByPlatform(ctx context.Context, arg ListPostsByPlatformParams) ([]*Post, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByPlatform, arg.Platform, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Post{}
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.QuoteID,
			&i.Platform,
			&i.PlatformPostID,
			&i.PostUrl,
			&i.TrendID,
			&i.TrendTitle,
			&i.TrendSource,
			&i.TrendHash,
			&i.RelevanceScore,
			&i.RelevanceReasoning,
			&i.VectorSimilarity,
			&i.Likes,
			&i.Reposts,
			&i.Replies,
			&i.PostedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotes = `-- name: ListQuotes :many
SELECT id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at FROM quotes ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListQuotesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListQuotes(ctx context.Context, arg ListQuotesParams) ([]*Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.TextHash,
			&i.SourceBook,
			&i.Chapter,
			&i.Character,
			&i.Themes,
			&i.ModernRelevance,
			&i.Embedding,
			&i.CharCount,
			&i.TimesPosted,
			&i.LastPostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByBook = `-- name: ListQuotesByBook :many
SELECT id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at FROM quotes WHERE source_book = ? ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByBook(ctx context.Context, sourceBook string) ([]*Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByBook, sourceBook)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.TextHash,
			&i.SourceBook,
			&i.Chapter,
			&i.Character,
			&i.Themes,
			&i.ModernRelevance,
			&i.Embedding,
			&i.CharCount,
			&i.TimesPosted,
			&i.LastPostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesWithEmbeddings = `-- name: ListQuotesWithEmbeddings :many
SELECT id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at FROM quotes WHERE embedding IS NOT NULL ORDER BY id
`

func (q *Queries) ListQuotesWithEmbeddings(ctx context.Context) ([]*Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesWithEmbeddings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.TextHash,
			&i.SourceBook,
			&i.Chapter,
			&i.Character,
			&i.Themes,
			&i.ModernRelevance,
			&i.Embedding,
			&i.CharCount,
			&i.TimesPosted,
			&i.LastPostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesWithoutEmbeddings = `-- name: ListQuotesWithoutEmbeddings :many
SELECT id, text, text_hash, source_book, chapter, character, themes, modern_relevance, embedding, char_count, times_posted, last_posted_at, created_at FROM quotes WHERE embedding IS NULL ORDER BY id LIMIT ?
`

func (q *Queries) ListQuotesWithoutEmbeddings(ctx context.Context, limit int64) ([]*Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesWithoutEmbeddings, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.TextHash,
			&i.SourceBook,
			&i.Chapter,
			&i.Character,
			&i.Themes,
			&i.ModernRelevance,
			&i.Embedding,
			&i.CharCount,
			&i.TimesPosted,
			&i.LastPostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedTrends = `-- name: ListUnmatchedTrends :many
SELECT id, source, external_id, title, url, description, score, embedding, matched, skipped, skip_reason, detected_at FROM trends
WHERE matched = FALSE AND skipped = FALSE
ORDER BY detected_at DESC LIMIT ?
`

func (q *Queries) ListUnmatchedTrends(ctx context.Context, limit int64) ([]*Trend, error) {
	rows, err := q.db.QueryContext(ctx, listUnmatchedTrends, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Trend{}
	for rows.Next() {
		var i Trend
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.ExternalID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Score,
			&i.Embedding,
			&i.Matched,
			&i.Skipped,
			&i.SkipReason,
			&i.DetectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setConfig = `-- name: SetConfig :exec
INSERT INTO config (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
`

type SetConfigParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) SetConfig(ctx context.Context, arg SetConfigParams) error {
	_, err := q.db.ExecContext(ctx, setConfig, arg.Key, arg.Value)
	return err
}

const updateExtractionJobCompleted = `-- name: UpdateExtractionJobCompleted :exec
UPDATE extraction_jobs
SET status = 'completed', completed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateExtractionJobCompleted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateExtractionJobCompleted, id)
	return err
}

const updateExtractionJobFailed = `-- name: UpdateExtractionJobFailed :exec
UPDATE extraction_jobs
SET status = 'failed', error_message = ?, completed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateExtractionJobFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateExtractionJobFailed(ctx context.Context, arg UpdateExtractionJobFailedParams) error {
	_, err := q.db.ExecContext(ctx, updateExtractionJobFailed, arg.ErrorMessage, arg.ID)
	return err
}

const updateExtractionJobProgress = `-- name: UpdateExtractionJobProgress :exec
UPDATE extraction_jobs
SET processed_chunks = ?, quotes_extracted = ?
WHERE id = ?
`

type UpdateExtractionJobProgressParams struct {
	ProcessedChunks sql.NullInt64 `json:"processed_chunks"`
	QuotesExtracted sql.NullInt64 `json:"quotes_extracted"`
	ID              int64         `json:"id"`
}

func (q *Queries) UpdateExtractionJobProgress(ctx context.Context, arg UpdateExtractionJobProgressParams) error {
	_, err := q.db.ExecContext(ctx, updateExtractionJobProgress, arg.ProcessedChunks, arg.QuotesExtracted, arg.ID)
	return err
}

const updateExtractionJobStarted = `-- name: UpdateExtractionJobStarted :exec
UPDATE extraction_jobs
SET status = 'running', total_chunks = ?, started_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateExtractionJobStartedParams struct {
	TotalChunks sql.NullInt64 `json:"total_chunks"`
	ID          int64         `json:"id"`
}

func (q *Queries) UpdateExtractionJobStarted(ctx context.Context, arg UpdateExtractionJobStartedParams) error {
	_, err := q.db.ExecContext(ctx, updateExtractionJobStarted, arg.TotalChunks, arg.ID)
	return err
}

const updatePostEngagement = `-- name: UpdatePostEngagement :exec
UPDATE posts SET likes = ?, reposts = ?, replies = ? WHERE id = ?
`

type UpdatePostEngagementParams struct {
	Likes   sql.NullInt64 `json:"likes"`
	Reposts sql.NullInt64 `json:"reposts"`
	Replies sql.NullInt64 `json:"replies"`
	ID      int64         `json:"id"`
}

func (q *Queries) UpdatePostEngagement(ctx context.Context, arg UpdatePostEngagementParams) error {
	_, err := q.db.ExecContext(ctx, updatePostEngagement,
		arg.Likes,
		arg.Reposts,
		arg.Replies,
		arg.ID,
	)
	return err
}

const updateQuoteEmbedding = `-- name: UpdateQuoteEmbedding :exec
UPDATE quotes SET embedding = ? WHERE id = ?
`

type UpdateQuoteEmbeddingParams struct {
	Embedding []byte `json:"embedding"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateQuoteEmbedding(ctx context.Context, arg UpdateQuoteEmbeddingParams) error {
	_, err := q.db.ExecContext(ctx, updateQuoteEmbedding, arg.Embedding, arg.ID)
	return err
}

const updateQuotePosted = `-- name: UpdateQuotePosted :exec
UPDATE quotes
SET times_posted = times_posted + 1, last_posted_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateQuotePosted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateQuotePosted, id)
	return err
}

const updateTrendEmbedding = `-- name: UpdateTrendEmbedding :exec
UPDATE trends SET embedding = ? WHERE id = ?
`

type UpdateTrendEmbeddingParams struct {
	Embedding []byte `json:"embedding"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateTrendEmbedding(ctx context.Context, arg UpdateTrendEmbeddingParams) error {
	_, err := q.db.ExecContext(ctx, updateTrendEmbedding, arg.Embedding, arg.ID)
	return err
}

const updateTrendMatched = `-- name: UpdateTrendMatched :exec
UPDATE trends SET matched = TRUE WHERE id = ?
`

func (q *Queries) UpdateTrendMatched(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateTrendMatched, id)
	return err
}

const updateTrendSkipped = `-- name: UpdateTrendSkipped :exec
UPDATE trends SET skipped = TRUE, skip_reason = ? WHERE id = ?
`

type UpdateTrendSkippedParams struct {
	SkipReason sql.NullString `json:"skip_reason"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateTrendSkipped(ctx context.Context, arg UpdateTrendSkippedParams) error {
	_, err := q.db.ExecContext(ctx, updateTrendSkipped, arg.SkipReason, arg.ID)
	return err
}
